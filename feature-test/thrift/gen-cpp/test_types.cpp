/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "test_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace thrift_test {


Record::~Record() throw() {
}


void Record::__set_ids(const std::vector<int64_t> & val) {
  this->ids = val;
}

void Record::__set_strings(const std::vector<std::string> & val) {
  this->strings = val;
}

uint32_t Record::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ids = false;
  bool isset_strings = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ids.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->ids.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readI64(this->ids[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          isset_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->strings.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readListBegin(_etype8, _size5);
            this->strings.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += iprot->readString(this->strings[_i9]);
            }
            xfer += iprot->readListEnd();
          }
          isset_strings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ids)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_strings)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Record::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Record");

  xfer += oprot->writeFieldBegin("ids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->ids.size()));
    std::vector<int64_t> ::const_iterator _iter10;
    for (_iter10 = this->ids.begin(); _iter10 != this->ids.end(); ++_iter10)
    {
      xfer += oprot->writeI64((*_iter10));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strings", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->strings.size()));
    std::vector<std::string> ::const_iterator _iter11;
    for (_iter11 = this->strings.begin(); _iter11 != this->strings.end(); ++_iter11)
    {
      xfer += oprot->writeString((*_iter11));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Record &a, Record &b) {
  using ::std::swap;
  swap(a.ids, b.ids);
  swap(a.strings, b.strings);
}

Record::Record(const Record& other12) {
  ids = other12.ids;
  strings = other12.strings;
}
Record& Record::operator=(const Record& other13) {
  ids = other13.ids;
  strings = other13.strings;
  return *this;
}
void Record::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Record(";
  out << "ids=" << to_string(ids);
  out << ", " << "strings=" << to_string(strings);
  out << ")";
}


RecordMissing::~RecordMissing() throw() {
}


void RecordMissing::__set_ids(const std::vector<int64_t> & val) {
  this->ids = val;
}

uint32_t RecordMissing::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ids = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ids.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->ids.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += iprot->readI64(this->ids[_i18]);
            }
            xfer += iprot->readListEnd();
          }
          isset_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ids)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RecordMissing::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RecordMissing");

  xfer += oprot->writeFieldBegin("ids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->ids.size()));
    std::vector<int64_t> ::const_iterator _iter19;
    for (_iter19 = this->ids.begin(); _iter19 != this->ids.end(); ++_iter19)
    {
      xfer += oprot->writeI64((*_iter19));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RecordMissing &a, RecordMissing &b) {
  using ::std::swap;
  swap(a.ids, b.ids);
}

RecordMissing::RecordMissing(const RecordMissing& other20) {
  ids = other20.ids;
}
RecordMissing& RecordMissing::operator=(const RecordMissing& other21) {
  ids = other21.ids;
  return *this;
}
void RecordMissing::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RecordMissing(";
  out << "ids=" << to_string(ids);
  out << ")";
}


RecordNewField::~RecordNewField() throw() {
}


void RecordNewField::__set_ids(const std::vector<int64_t> & val) {
  this->ids = val;
}

void RecordNewField::__set_strings(const std::vector<std::string> & val) {
  this->strings = val;
}

void RecordNewField::__set_id(const int64_t val) {
  this->id = val;
}

uint32_t RecordNewField::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ids = false;
  bool isset_strings = false;
  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ids.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->ids.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += iprot->readI64(this->ids[_i26]);
            }
            xfer += iprot->readListEnd();
          }
          isset_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->strings.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->strings.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += iprot->readString(this->strings[_i31]);
            }
            xfer += iprot->readListEnd();
          }
          isset_strings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ids)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_strings)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RecordNewField::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RecordNewField");

  xfer += oprot->writeFieldBegin("ids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->ids.size()));
    std::vector<int64_t> ::const_iterator _iter32;
    for (_iter32 = this->ids.begin(); _iter32 != this->ids.end(); ++_iter32)
    {
      xfer += oprot->writeI64((*_iter32));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strings", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->strings.size()));
    std::vector<std::string> ::const_iterator _iter33;
    for (_iter33 = this->strings.begin(); _iter33 != this->strings.end(); ++_iter33)
    {
      xfer += oprot->writeString((*_iter33));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RecordNewField &a, RecordNewField &b) {
  using ::std::swap;
  swap(a.ids, b.ids);
  swap(a.strings, b.strings);
  swap(a.id, b.id);
}

RecordNewField::RecordNewField(const RecordNewField& other34) {
  ids = other34.ids;
  strings = other34.strings;
  id = other34.id;
}
RecordNewField& RecordNewField::operator=(const RecordNewField& other35) {
  ids = other35.ids;
  strings = other35.strings;
  id = other35.id;
  return *this;
}
void RecordNewField::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RecordNewField(";
  out << "ids=" << to_string(ids);
  out << ", " << "strings=" << to_string(strings);
  out << ", " << "id=" << to_string(id);
  out << ")";
}


RecordRename::~RecordRename() throw() {
}


void RecordRename::__set_ids_rem(const std::vector<int64_t> & val) {
  this->ids_rem = val;
}

void RecordRename::__set_strings_rem(const std::vector<std::string> & val) {
  this->strings_rem = val;
}

uint32_t RecordRename::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ids_rem = false;
  bool isset_strings_rem = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ids_rem.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->ids_rem.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += iprot->readI64(this->ids_rem[_i40]);
            }
            xfer += iprot->readListEnd();
          }
          isset_ids_rem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->strings_rem.clear();
            uint32_t _size41;
            ::apache::thrift::protocol::TType _etype44;
            xfer += iprot->readListBegin(_etype44, _size41);
            this->strings_rem.resize(_size41);
            uint32_t _i45;
            for (_i45 = 0; _i45 < _size41; ++_i45)
            {
              xfer += iprot->readString(this->strings_rem[_i45]);
            }
            xfer += iprot->readListEnd();
          }
          isset_strings_rem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ids_rem)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_strings_rem)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RecordRename::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RecordRename");

  xfer += oprot->writeFieldBegin("ids_rem", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->ids_rem.size()));
    std::vector<int64_t> ::const_iterator _iter46;
    for (_iter46 = this->ids_rem.begin(); _iter46 != this->ids_rem.end(); ++_iter46)
    {
      xfer += oprot->writeI64((*_iter46));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strings_rem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->strings_rem.size()));
    std::vector<std::string> ::const_iterator _iter47;
    for (_iter47 = this->strings_rem.begin(); _iter47 != this->strings_rem.end(); ++_iter47)
    {
      xfer += oprot->writeString((*_iter47));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RecordRename &a, RecordRename &b) {
  using ::std::swap;
  swap(a.ids_rem, b.ids_rem);
  swap(a.strings_rem, b.strings_rem);
}

RecordRename::RecordRename(const RecordRename& other48) {
  ids_rem = other48.ids_rem;
  strings_rem = other48.strings_rem;
}
RecordRename& RecordRename::operator=(const RecordRename& other49) {
  ids_rem = other49.ids_rem;
  strings_rem = other49.strings_rem;
  return *this;
}
void RecordRename::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RecordRename(";
  out << "ids_rem=" << to_string(ids_rem);
  out << ", " << "strings_rem=" << to_string(strings_rem);
  out << ")";
}


RecordTypes::~RecordTypes() throw() {
}


void RecordTypes::__set_ids(const std::vector<double> & val) {
  this->ids = val;
}

void RecordTypes::__set_strings(const std::vector<std::string> & val) {
  this->strings = val;
}

uint32_t RecordTypes::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ids = false;
  bool isset_strings = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ids.clear();
            uint32_t _size50;
            ::apache::thrift::protocol::TType _etype53;
            xfer += iprot->readListBegin(_etype53, _size50);
            this->ids.resize(_size50);
            uint32_t _i54;
            for (_i54 = 0; _i54 < _size50; ++_i54)
            {
              xfer += iprot->readDouble(this->ids[_i54]);
            }
            xfer += iprot->readListEnd();
          }
          isset_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->strings.clear();
            uint32_t _size55;
            ::apache::thrift::protocol::TType _etype58;
            xfer += iprot->readListBegin(_etype58, _size55);
            this->strings.resize(_size55);
            uint32_t _i59;
            for (_i59 = 0; _i59 < _size55; ++_i59)
            {
              xfer += iprot->readString(this->strings[_i59]);
            }
            xfer += iprot->readListEnd();
          }
          isset_strings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ids)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_strings)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RecordTypes::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RecordTypes");

  xfer += oprot->writeFieldBegin("ids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->ids.size()));
    std::vector<double> ::const_iterator _iter60;
    for (_iter60 = this->ids.begin(); _iter60 != this->ids.end(); ++_iter60)
    {
      xfer += oprot->writeDouble((*_iter60));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strings", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->strings.size()));
    std::vector<std::string> ::const_iterator _iter61;
    for (_iter61 = this->strings.begin(); _iter61 != this->strings.end(); ++_iter61)
    {
      xfer += oprot->writeString((*_iter61));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RecordTypes &a, RecordTypes &b) {
  using ::std::swap;
  swap(a.ids, b.ids);
  swap(a.strings, b.strings);
}

RecordTypes::RecordTypes(const RecordTypes& other62) {
  ids = other62.ids;
  strings = other62.strings;
}
RecordTypes& RecordTypes::operator=(const RecordTypes& other63) {
  ids = other63.ids;
  strings = other63.strings;
  return *this;
}
void RecordTypes::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RecordTypes(";
  out << "ids=" << to_string(ids);
  out << ", " << "strings=" << to_string(strings);
  out << ")";
}

} // namespace
